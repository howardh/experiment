import re
import os
import time
import itertools
import pprint
from abc import ABC, abstractmethod
from typing import Optional, Type, Mapping, TypeVar, Generic
import warnings

import dill
from tqdm import tqdm

from .utils import find_next_free_dir, dill_dump_rolling, dill_load_rolling

class Experiment(ABC): # pragma: no cover
    @abstractmethod
    def setup(self, config, output_directory=None):
        pass
    @abstractmethod
    def run_step(self,iteration):
        pass

    def state_dict(self):
        return {}
    def load_state_dict(self,state):
        state = state
        pass

def get_experiment_directories(*,
        root_directory, results_directory, experiment_name, trial_id):
    if results_directory is None:
        if trial_id is None:
            trial_id = time.strftime("%Y_%m_%d-%H_%M_%S")
            results_directory = find_next_free_dir(
                    root_directory,
                    '{}-{}-%d'.format(experiment_name, trial_id)
            )
        else:
            results_directory = os.path.join(
                    root_directory, '{}-{}'.format(experiment_name, trial_id))
    checkpoint_file_path = os.path.join(
            results_directory,'checkpoint.pkl')
    experiment_output_directory = os.path.join(
            results_directory, 'output')
    return {
            'results': results_directory,
            'checkpoint': checkpoint_file_path,
            'output': experiment_output_directory
    }

def sub_env_var(val : Optional[str]) -> Optional[str]:
    """
    Find substrings of the format '{$ENV_VAR_NAME}' and substitute them with the value of the corresponding environment variable. Return the string with the substitutions.
    """
    if val is None:
        return None
    pattern = r'\{\$([a-zA-Z_]+)\}'
    def sub(match) -> str:
        var_name = match.group(1)
        if var_name in os.environ:
            return os.environ[var_name]
        return '{$%s}' % var_name
    return re.sub(pattern, sub, val)

ExpType = TypeVar('ExpType', bound=Experiment) # Must be a subclass of `Experiment`
class ExperimentRunner(Generic[ExpType]):
    def __init__(self,
            cls : Type[ExpType],
            *, # All following arguments must be named (i.e. cannot be positional)
            experiment_name : Optional[str] = None,
            root_directory : str = './results',
            trial_id : Optional[str] = None,
            results_directory : Optional[str] = None,
            max_iterations : Optional[int] = None,
            verbose : bool = False,
            checkpoint_frequency : Optional[int] = 10000,
            num_checkpoints : int = 2,
            config : Mapping = {}):
        """
        Args:
            cls (Experiment): The class defining the experiment to run.
            root_directory (str): If specified, then a directory is created in this directory for all files generated by this experiment.
            experiment_name (str): Name given to the experiment, to be used in naming the directory in which results are saved. Defaults to the name of the Experiment class provided.
            results_directory (str): Directory which holds all files generated by the current experiment trial. If not specified, then a new directory is created in the root directory for this purpose.
                If an existing directory is specified, then it is loaded as a checkpoint.
            trial_id (str): An ID associated with this trial. If an existing checkpoint is found with the given ID in the root directory, then that checkpoint is loaded instead of starting a new run. Environment variables can be used in the trial ID. For example, if the ID is to be the environment variable `SLURM_ARRAY_TASK_ID`, then set `trial_id` to `"{$SLURM_ARRAY_TASK_ID}"`.
            epoch (int): Number of steps in an epoch
            max_iterations (int): The maximum number of iterations to run. If `None`, then there is no limit.
            checkpoint_frequency (int): Number of steps between each saved checkpoint.
            num_checkpoints (int): The number of checkpoints to keep on disk.
            config (collections.abc.Mapping): Parameters that are passed to the experiment's `setup` method.
        """
        kwargs = locals()
        del kwargs['self']
        self.args = kwargs

        self.config = config
        self.experiment_name = experiment_name
        self.root_directory = sub_env_var(root_directory)
        self.results_directory = sub_env_var(results_directory)
        self.verbose = verbose
        self.trial_id = sub_env_var(trial_id)
        self.checkpoint_frequency = checkpoint_frequency
        self.max_iterations = max_iterations
        self.num_checkpoints = num_checkpoints

        directories = get_experiment_directories(
                root_directory=self.root_directory,
                results_directory=self.results_directory,
                experiment_name=experiment_name,
                trial_id=trial_id
        )
        self.results_directory = directories['results']
        self.checkpoint_file_path = directories['checkpoint']
        self.experiment_output_directory = directories['output']
        os.makedirs(self.experiment_output_directory, exist_ok=True)

        self.steps = 0
        if self.max_iterations is None:
            self.step_range = itertools.count(self.steps)
        else:
            self.step_range = range(self.steps,self.max_iterations)

        cls = kwargs['cls']
        self.exp = cls()
        self.exp.setup(
                config=self.config,
                output_directory=self.experiment_output_directory
        )

    def setup(self, **kwargs):
        kwargs = kwargs
        pass

    def run(self):
        step_range = self.step_range
        if self.verbose:
            pprint.pprint(self.args)
            if self.max_iterations is None:
                step_range = tqdm(step_range)
            else:
                step_range = tqdm(step_range, total=self.max_iterations, initial=self.steps)
        for steps in step_range:
            self.steps = steps
            if self.checkpoint_frequency is not None and steps % self.checkpoint_frequency == 0:
                self.save_checkpoint(self.checkpoint_file_path)
            self.exp.run_step(steps)
        # Save final checkpoint
        if self.max_iterations is not None and self.steps == self.max_iterations-1: # Ensure that we've just reached the end of the previous loop, and did not call `run()` a second time.
            self.steps += 1
            self.save_checkpoint(self.checkpoint_file_path)
    def save_checkpoint(self, filename):
        results = self.state_dict()
        filenames = [filename] + ['%s.%d' % (filename,i) for i in range(self.num_checkpoints)]
        dill_dump_rolling(results,filenames)
        if self.verbose:
            tqdm.write('Checkpoint saved at %s' % os.path.abspath(filename))

    def state_dict(self):
        output = {
            'args': {
                **self.args,
                'cls': str(self.args['cls']),
                'results_directory': self.results_directory,
            },
            'steps': self.steps,
            'exp': self.exp.state_dict()
        }
        return output

    def load_state_dict(self, state):
        # Experiment progress
        self.setup(**state.get('args'))
        self.exp.load_state_dict(state.get('exp'))

        self.steps = state['steps']
        if self.max_iterations is None:
            self.step_range = itertools.count(self.steps)
        else:
            self.step_range = range(self.steps,self.max_iterations)

def make_experiment_runner(cls : Type[ExpType],
            *, # All following arguments must be named (i.e. cannot be positional)
            experiment_name : Optional[str] = None,
            root_directory : str = './results',
            trial_id : Optional[str] = None,
            results_directory : Optional[str] = None,
            max_iterations : Optional[int] = None,
            verbose : bool = False,
            checkpoint_frequency : Optional[int] = 10000,
            num_checkpoints : int = 2,
            config : Mapping = {}) -> ExperimentRunner[ExpType]:

    experiment_name = experiment_name or cls.__name__

    directories = get_experiment_directories(
            root_directory=root_directory,
            results_directory=results_directory,
            experiment_name=experiment_name,
            trial_id=trial_id
    )

    checkpoint_filename = directories['checkpoint']
    if not os.path.isfile(checkpoint_filename):
        return ExperimentRunner(cls, experiment_name=experiment_name, root_directory=root_directory,trial_id=trial_id, results_directory=results_directory, max_iterations=max_iterations, verbose=verbose, checkpoint_frequency=checkpoint_frequency,num_checkpoints=num_checkpoints,config=config)

    return load_checkpoint(cls,checkpoint_filename)

def load_checkpoint(cls, path):
    if os.path.isfile(path):
        with open(path,'rb') as f:
            state = dill.load(f)
    elif os.path.isdir(path):
        num_files = len(os.listdir(path))
        filename = os.path.join(path,'checkpoint.pkl')
        filenames = [filename]+['%s.%d' % (filename,i) for i in range(num_files)]
        state = dill_load_rolling(filenames)
    else:
        raise Exception('Checkpoint does not exist: %s' % path)

    # Check that the given class matches with the checkpoint experiment class
    # Or it it is a child class of the original
    cls_name = state['args'].pop('cls')
    parent_cls_names = (str(parent_cls_name) for parent_cls_name in cls.__bases__)
    if cls_name != str(cls) and cls_name not in parent_cls_names:
        warnings.warn('Experiment class mismatch. Expected %s. Found %s. Creating an experiment of type %s. This may not behave as expected.' % (cls_name,cls,cls))

    # Create experiment runner with
    if 'epoch' in state['args']:
        warnings.warn('`epoch` parameter found in loaded state. Ignoring parameter.')
        del state['args']['epoch']
    exp = ExperimentRunner(cls, **state['args']) # cls needs to be passed as a positional argument, otherwise it fails in python 3.7. See https://stackoverflow.com/questions/62235830/why-is-the-cls-keyword-attribute-reserved-when-using-typing-generic-in-python
    exp.load_state_dict(state)
    return exp
